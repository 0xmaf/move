Function info is derived from `AnnotatedCompiledModule`s. 

> Their construction is described in `to_bytecode::translate::module()`. 

`FunctionInfo`s are derived from `cfgir::ast::ModuleDefinition`'s `functions` field.

> I would assume that the `FunctionInfo`s here refers to the module we are scanning, Not strictly the dependencies.

The derived components are then transformed into function infos we use to construct an `AnnotatedCOmpiledModule` with the function:
```
fn module_function_infos(
	compile_module: &F::CompiledModule,
	source_map: &SourceMap,
	collected_function_infos: &CollectedInfos,
) -> UniqueMap<FunctionName, FunctionInfo> {...}
```

> The question here would then be: Can we derive `cfgir::ast::FunctionInfo`s or `CompiledUnit::FunctionInfo`s  from our `CompiledModule`?

It seems that we *can* derive function parameters from `CompiledModule`s.

> What about attributes?

> Seeing that `compiled_unit::FunctionInfo` has a `spec_info` field and given that `compiled_unit::FunctionInfo` is derived from `cfgir::ast::ModuleDefinition.functions` it seems that there may be some spec target analysis done during the cfgir stage of compilation.

### we're dealing with `move_compiler::compiled_unit::FunctionInfo`
```
pub struct FunctionInfo {
	pub spec_info: BTreeMap<SpecId, SpecInfo>,
	pub parameters: Vec<(Var, VarInfo)>,
	pub attributes: Attributes,
}
```

`Attributes` is `expansion::ast::Attributes`
`Var` is `parser::ast::Var`

> A note on `Var`: `parser::ast` calls the macro `new_name!(Var)`. It's similar to `ModuleName` and the like.

`VarInfo` is defined, where `H` is `hlir` and `F` is `file_format`, as:
```
pub struct VarInfo {
	pub type_: H::SingleType,
	pub index: F::LocalIndex,
}
```
`SpecId` is `expansion::ast::SpecId`
`SpecInfo` is defined as:
```
pub struct SpecInfo {
	pub offset: F::CodeOffset,
	// Free locals that are used but not declared in the block
	pub used_locals: UniqueMap<Var, VarInfo>,
}
```

**The elements we are missing given file_format::CompiledModule and expansion::ast::ModuleDefinition of expansion::ast::Spec is:**
- `H::SingleType`

> It's also important that we look at how `SpecInfo` is created. We want to know where we got `offset` and `used_locals`.

### [`move_compiler::to_bytecode::translate`](https://github.com/move-language/move/blob/81d19fce20d73675b7ac129abe6b6797513cc8d0/language/move-compiler/src/to_bytecode/translate.rs)

We're mostly dealing with the `function_info_map()` function.

Given that we extract specs from `CollectedInfos` provided to `function_info_map()` and its caller `module_function_infos()`, and given that they are derived from a `<G::ModuleDefinition>.functions`, it is likely that the specs merged into functions sometime after expansion.

Info is generated by the `function()` function.

```
fn function(
	context: &mut Context,
	m: Option<&ModuleIdent>,
	f: FunctionName,
	fdef: G::Function,
) -> ((IR::FunctionName, IR::Function), CollectedInfo) {...}
```

Judging from the inner implementation of this function, `CollectedInfo` is a type alias.

```
type CollectedInfo = (
	Vec<(Var, H::SingleType)>,
	BTreeMap<SpecId, (IR::NopLabel, BTreeMap<Var, H::SingleType>)>,
	Attributes,
);

type CollectedInfos = UniqueMap<FunctionName, CollectedInfo>;
```

> I'm concerned about sourcing this `BTreeMap`...

Judging from this line in `function_info_map()`, this `BTreeMap` is a map of `E::SpecId` to tuple that consists of `IR::NopLabel` anda `BTreeMap` of `Var` to `H::SingleType`.
```
let (params, specs, attributes) = collected_function_infos.get_(&name).unwrap();
```

Judging from the signature of `function_info_map()` we only need to derive `CollectedInfos` to generate `FunctionInfo`:
```
fn function_info_map(
	compile_module: &F::CompiledModule,
	source_map: &SourceMap,
	collected_function_infos: &CollectedInfos,
	idx: F::FunctionDefinitionIndex,
) -> (FunctionName, FunctionInfo) {...}
```

### we're only dealing with globals. how do we enforce it?
We don't have to worry about this w.r.t `SpecInfo`. Expansion holds that information. I suspect that `SpecInfo` exists (inside of `FunctionInfo`) to help the prover (and probably the model builder) know which functions to target(?)

> Turns out `SpecBlock` holds that info regarding targets. 

```
pub struct SpecBlock_ {
	pub attributes: Attributes,
	pub target: SpecBlockTarget,
	pub members: Vec<SpecBlockMember>,
}

pub type SpecBlock = Spanned<SpecBlock_>;
```

It should also provide information regarding free locals that are used but not declared in the code block.

> a "free local" is not a local since it is not declared in that block. it is likely a static or global variable (in this case it is global to the chain).

> **We should really consider how we'll merge specs with our `E::ModuleDefinition`/`E::Script`.** We can't really rely on `expansion::merge_spec_modules` since that only deals with the `parser::ast` level.

**Remember that we're trying to make modules the targets, not functions...**
But what about if the return value of a function is important? What if it returns a resource and we just need to store it under our account to finalize that change to global state?
Hmm then we'd need to start with the expansion ast and iterate through all functions (with some resource use based filtering ideally - perhaps the read-write-set analysis) and specify them as targets.

> **Models are post-condition specific! So we would have to generate a new model for each new post-condition. For some reason, I'm starting to sense the importance of read-write-set analysis.**

